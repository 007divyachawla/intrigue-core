module Intrigue
class UriExploitable < BaseTask

  include Intrigue::Task::Web

  def metadata
    {
      :name => "uri_exploitable",
      :pretty_name => "URI Exploitable Scanner",
      :authors => ["jcran", "@0xsauby"],
      :description => "Bruteforce common paths on a web server looking for exploitable and interesting applications",
      :references => [],
      :allowed_types => ["Uri"],
      :example_entities => [
        {"type" => "Uri", "attributes" => {"name" => "http://intrigue.io"}}
      ],
      :allowed_options => [
        {:name => "threads", :type => "Integer", :regex => "integer", :default => 1 }
      ],
      :created_types => ["Uri"]
    }
  end

  def run
    super

    # Get the uri
    uri = _get_entity_attribute("name")
    opt_threads = _get_option("threads")

    # https://github.com/danielmiessler/SecLists/blob/master/vulns/apache.txt
    brute_list = JSON.parse File.read("#{$intrigue_basedir}/data/exploitable.json")

    ###
    ### Get the default case (a page that doesn't exist)
    ###
    response = http_get "#{uri}/#{rand(100000000)}"
    unless response
      @task_result.logger.log_error "Unable to connect to site"
      return false
    end

    # Default to code
    missing_page_test = :code
    # But select based on the response to our random page check
    case response.code
      when "404"
        @missing_page_test = :code
      when "200"
        @missing_page_test = :content
        @missing_page_content = response.body
      else
        @missing_page_test = :code
        @missing_page_code = response.code
    end

    # Log our method
    @task_result.logger.log "Missing Page Test: #{missing_page_test}"

    # Create our queue of work from the checks in brute_list
    work_q = Queue.new
    brute_list.each do |item|
      item["check_paths"].each do |dir|
        request_uri = "#{uri}#{"/" unless uri[-1] == "/"}#{dir}"
        work_q << request_uri
      end
    end

    # Create a pool of worker threads to work on the queue
    workers = (0...opt_threads).map do
      Thread.new do
        begin
          while uri = work_q.pop(true)

            # Do the check
            check_uri uri

          end # end while
        rescue ThreadError
        end
      end
    end; "ok"
    workers.map(&:join); "ok"
  end # end run

  def check_uri(request_uri)

    @task_result.logger.log "Attempting #{request_uri}"
    response = http_get request_uri
    return false unless response

    ## If we are able to guess based on the code, we're super lucky!
    if @missing_page_test == :code
      case response.code
        when "404"
          @task_result.logger.log "404 on #{request_uri}"
        when "200"
          @task_result.logger.log_good "200! Creating a page for #{request_uri}"
          _create_entity "Uri",
            "name" => request_uri,
            "uri" => request_uri,
            "response_code" => response.code
        when "500"
          @task_result.logger.log_good "500 error! Creating a page for #{request_uri}"
          #_create_entity "Uri",
          #  "name" => request_uri,
          #  "uri" => request_uri,
          #  "response_code" => response.code
        when @missing_page_code
          @task_result.logger.log "Got code: #{response.code}. Same as missing page code. Skipping"
        else
          @task_result.logger.log_error "Don't know this response code? #{response.code} (#{request_uri})"
          #_create_entity "Uri",
          #  "name" => request_uri,
          #  "uri" => request_uri,
          #  "response_code" => response.code
      end

    ## Otherwise, let's guess based on the content. Does this page look
    ## like a missing page?
    elsif @missing_page_test == :content
      if response.body[0..100] == @missing_page_content[0..100]
        @task_result.logger.log "Skipping #{request_uri} based on page content"
      elsif response.body.include? "404"
        @task_result.logger.log "Skipping #{request_uri}, contains the string: 404"
      elsif (response.code == 302 ||
            response.code == 301 ||
            response.code == 401 ||
            response.code == 404 ||
            response.code == 500)
        @task_result.logger.log "Skipping #{request_uri} based on code: #{response.code}"
      else
        @task_result.logger.log "Flagging #{request_uri}!"
        _create_entity "Uri",
          "name" => request_uri,
          "uri" => request_uri,
          "response_code" => response.code
      end
    end
  end

end
end
